module XenConfigFile
  grammar Grammar
    rule config_file
      (comment / blank_line / assignment)* <AST.create_node(:config_file)>
    end

    rule assignment
      space_no_newline* name:variable space_no_newline* '=' space_no_newline* value:variable space* comment* <AST.create_node(:assignment)>
      /
      space_no_newline* &"disk" name:variable space_no_newline* '=' space_no_newline* '[' space* value:disk_array_list space* ']' space* comment* <AST.create_node(:assignment)>
      /
      space_no_newline* name:variable space_no_newline* '=' space_no_newline* '[' space* value:array_list space* ']' space* comment* <AST.create_node(:assignment)>
    end

    # need to define build inline since it's a recursive rule
    # TODO reexamine the requirements for ,'s and inline comments
    rule array_list
      space* value:(variable/comment) ','? space* remains:(space* list:array_list space* ','?)* {
        def build
          ([value.build] + remains.elements.map { |e| e.list.build }).flatten
        end
      }
    end

    # have to be careful with the recursive building of nodes -- each list gets iterated over list.size times
    # maybe there's a better way to define lists of disks?
    rule disk_array_list
      space* value:(variable/comment) ','? space* remains:(space* list:disk_array_list space* ','?)* {
        def build
          ([AST::Disk.new(value.build)] + remains.elements.map { |e| e.list.build }).flatten
        end
      }
    end

    # note the pass-through, a variable node is never instantiated as a part of the treehouse AST,
    # so either the node needs to know how to get to to the underlying value via build
    # using an inline definition as you see here, or the lhs/rhs of a variable's parent node
    # can be defined with a lambda to do the pass-through there, e.g.
    #   node :array_assignment, :rhs, :lhs => lambda { |node| node.lhs.value.build }
    # In this case, the inline build is simpler than remembering in the AST node definitions where
    # variables are expected as children everywhere they're used
    rule variable
      space_no_newline* value:number space* comment* {
        def build
          value.build
        end
      }
      /
      space_no_newline* value:string space* comment* {
        def build
          value.build
        end
      }
    end

    rule number
      [0-9]+ {
        def build
          text_value.to_i
        end
      }
    end

    rule string
      ([A-Za-z_-])+ {
        def build
          text_value
        end
      }
      /
      '"' (!'"' . / '\"')* '"' {
        def build
          elements[1].text_value
        end
      }
      /
      "'" (!"'" .)* "'" {
        def build
          elements[1].text_value
        end
      }
    end

    rule comment
      space_no_newline* '#' value:([^\n])* "\n" <AST.create_node(:comment)>
    end

    rule blank_line
      "\n"
    end

    rule space_no_newline
      [ \t]
    end

    rule space
      space_no_newline / "\n"
    end
  end
end
